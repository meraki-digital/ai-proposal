# Invite-Only Registration

**Category:** Authentication / Security Pattern
**Official Docs:** (Pattern - see related authentication documentation)
**Used In:** Superscapes Financial Intelligence Dashboard - Authentication RDS Management

---

## What Is It?

Invite-only registration is an authentication pattern where new users can only create accounts through invitation links generated by administrators. Unlike public registration (where anyone can sign up), invite-only registration gives you complete control over who accesses your application.

Think of it like a private club membership: you can't just walk in and join. Someone already in the club (an admin) must invite you, giving you a special one-time membership form (invite token) to complete your registration.

---

## Why We're Using It In This Project

- **Controlled access** - Financial dashboard contains sensitive data; only authorized users should access it
- **Client requirement** - Client wants to manually approve all users before granting access
- **Security** - Prevents public discovery and unauthorized account creation
- **User tracking** - Know exactly who invited each user for audit trails
- **Phased rollout** - Gradually expand user base without opening floodgates

---

## How We'll Use It

**Example 1: Admin Creates Invitation**
```python
import uuid
import secrets
from datetime import datetime, timedelta
import boto3

dynamodb = boto3.client('dynamodb')

def create_invitation(admin_user_id: str, email: str, role: str = 'user'):
    # Generate secure one-time token
    invite_token = secrets.token_urlsafe(32)  # 32-byte random token
    user_id = str(uuid.uuid4())
    invite_expires_at = datetime.utcnow() + timedelta(days=7)

    # Create pending user record in DynamoDB
    dynamodb.put_item(
        TableName='auth-users',
        Item={
            'user_id': {'S': user_id},
            'email': {'S': email},
            'role': {'S': role},
            'invite_token': {'S': invite_token},
            'invite_expires_at': {'S': invite_expires_at.isoformat()},
            'is_active': {'BOOL': False},  # Not active until invite accepted
            'created_by': {'S': admin_user_id},
            'created_at': {'S': datetime.utcnow().isoformat()}
        }
    )

    # Return invite URL for admin to send to user
    invite_url = f"https://dashboard.superscapes.com/auth/invite/{invite_token}"
    return {
        'invite_url': invite_url,
        'email': email,
        'expires_at': invite_expires_at.isoformat()
    }
```

**Example 2: User Accepts Invitation**
```python
import bcrypt

def complete_invite(invite_token: str, password: str, full_name: str):
    # Look up user by invite token
    response = dynamodb.scan(
        TableName='auth-users',
        FilterExpression='invite_token = :token',
        ExpressionAttributeValues={':token': {'S': invite_token}}
    )

    if response['Count'] == 0:
        raise ValueError('Invalid invite token')

    user = response['Items'][0]

    # Check expiration
    if user['invite_expires_at']['S'] < datetime.utcnow().isoformat():
        raise ValueError('Invite token has expired')

    # Check if already activated
    if user['is_active']['BOOL']:
        raise ValueError('Invite already used')

    # Hash password
    password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(rounds=12))

    # Activate user account
    dynamodb.update_item(
        TableName='auth-users',
        Key={'user_id': {'S': user['user_id']['S']}},
        UpdateExpression='SET password_hash = :ph, full_name = :fn, is_active = :active, invite_token = :null, password_changed_at = :now',
        ExpressionAttributeValues={
            ':ph': {'S': password_hash.decode('utf-8')},
            ':fn': {'S': full_name},
            ':active': {'BOOL': True},
            ':null': {'NULL': True},
            ':now': {'S': datetime.utcnow().isoformat()}
        }
    )

    return {'success': True, 'email': user['email']['S']}
```

**Example 3: Admin Invitation Endpoint (FastAPI)**
```python
from fastapi import Depends, HTTPException
from pydantic import BaseModel, EmailStr

class InviteRequest(BaseModel):
    email: EmailStr
    role: str = 'user'  # Default to 'user' role

@app.post('/api/auth/invite')
def create_invite(request: InviteRequest, current_user: dict = Depends(require_admin)):
    # Check if email already exists
    if email_exists(request.email):
        raise HTTPException(status_code=400, detail='Email already registered')

    # Create invitation
    result = create_invitation(
        admin_user_id=current_user['user_id'],
        email=request.email,
        role=request.role
    )

    # In production, send email here instead of returning URL
    # send_email(to=request.email, subject='Invitation to Dashboard', body=result['invite_url'])

    return result
```

**Example 4: Public Invite Acceptance Endpoint**
```python
class CompleteInviteRequest(BaseModel):
    invite_token: str
    password: str
    full_name: str

@app.post('/api/auth/complete-invite')
def accept_invite(request: CompleteInviteRequest):
    # Validate password requirements
    if len(request.password) < 8:
        raise HTTPException(status_code=400, detail='Password must be at least 8 characters')

    if not any(char.isdigit() for char in request.password):
        raise HTTPException(status_code=400, detail='Password must contain at least one number')

    try:
        result = complete_invite(request.invite_token, request.password, request.full_name)
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
```

---

## Key Concepts

- **Invite Token:** Cryptographically secure random string (32+ bytes) that grants one-time registration access
- **Expiration:** Invite links expire after set period (7 days) to limit window of vulnerability
- **One-Time Use:** Token is nullified after acceptance to prevent reuse
- **Pending User:** User record created at invitation time but not activated until password set
- **Admin-Created:** Only users with admin role can generate invitations

---

## Alternatives We Considered

- **Public registration with email verification:** Anyone could create account; requires spam prevention
- **Admin creates accounts with temp passwords:** Less secure; admin knows initial password
- **OAuth-only (Google, GitHub):** Limits control over who can access; relies on external providers
- **Approval workflow:** Users request access and wait for approval; slower UX

---

## Getting Started

1. **Add invite fields to DynamoDB schema:**
   ```python
   # See create_invitation() example above
   # Fields: invite_token, invite_expires_at, is_active, created_by
   ```

2. **Create admin endpoint:**
   ```python
   # Implement POST /api/auth/invite (admin only)
   ```

3. **Create public acceptance endpoint:**
   ```python
   # Implement POST /api/auth/complete-invite (no auth required)
   ```

4. **Build frontend invite form:**
   ```tsx
   // Form at /auth/invite/:token route
   // Inputs: full name, password, confirm password
   ```

5. **Test flow:**
   ```bash
   # Admin creates invite
   curl -X POST /api/auth/invite -H "Authorization: Bearer $ADMIN_TOKEN" \
     -d '{"email":"newuser@example.com","role":"user"}'

   # User accepts invite
   curl -X POST /api/auth/complete-invite \
     -d '{"invite_token":"abc123","password":"secure123","full_name":"New User"}'
   ```

---

## Common Patterns & Best Practices

1. **Use cryptographic random tokens** - `secrets.token_urlsafe()` in Python, not predictable UUIDs
2. **Set reasonable expiration** - 7 days balances security and UX
3. **Nullify token after use** - Set to NULL in database to prevent replay attacks
4. **Email invite links** - Don't show URLs in admin UI in production; send via email
5. **Track invitation source** - Store `created_by` admin ID for audit trails

---

## Troubleshooting

**Issue 1:** Users can't find invite email
**Solution:** Implement resend functionality or show invite URL to admin temporarily for manual sharing

**Issue 2:** Invite token expired before user registered
**Solution:** Add admin endpoint to regenerate invite for same email

**Issue 3:** User clicks invite link multiple times
**Solution:** Show friendly message if `is_active = true`; redirect to login

**Issue 4:** Email already exists in system
**Solution:** Check `email_exists()` before creating invite; return clear error message

---

## Learning Resources

**Essential:**
- [Python secrets module](https://docs.python.org/3/library/secrets.html)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)

**Recommended:**
- [Secure Token Generation](https://security.stackexchange.com/questions/3001/what-is-a-cryptographically-secure-random-number-generator)
- [Invitation Flow UX Patterns](https://www.nngroup.com/articles/invitation-pattern/)

**Community:**
- [r/webdev Authentication Discussions](https://www.reddit.com/r/webdev/)

---

**Related Technologies:**
- [Custom JWT Implementation](custom-jwt-implementation.md) - Overall authentication architecture
- [AWS DynamoDB](aws-dynamodb.md) - Storage for invite tokens and user data
- [bcrypt](bcrypt.md) - Password hashing when user accepts invite
- [FastAPI](fastapi.md) - Backend endpoints for invite creation and acceptance
- [Role-Based Access Control](rbac.md) - Admin role requirement for creating invites
