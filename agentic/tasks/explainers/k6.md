# k6

**Category:** Testing  
**Official Docs:** [https://k6.io/docs/](https://k6.io/docs/)  
**Used In:** Superscapes Financial Intelligence Dashboard - MVP

---

## What Is It?

k6 is an open-source load testing tool designed for testing the performance and reliability of APIs, microservices, and websites. It uses a JavaScript-based scripting approach to define test scenarios, supports distributed execution, and provides comprehensive metrics and visualizations. k6 can simulate thousands of concurrent users and generate detailed performance reports.

Think of k6 as a stress-testing gym for your application. Just as athletes train under extreme conditions to build strength, k6 puts your API under heavy load to ensure it can handle real-world usage patterns and identify performance bottlenecks before they affect users.

---

## Why We're Using It In This Project

k6 ensures our financial dashboard can handle production load:

- **Load testing**: Verify performance under realistic user loads
- **API performance**: Test FastAPI endpoints response times and throughput
- **Scalability validation**: Ensure AWS ECS Fargate auto-scaling works
- **Bottleneck identification**: Find performance issues before production
- **CI/CD integration**: Automated performance regression testing
- **Realistic scenarios**: Test actual user behavior patterns
- **Resource monitoring**: Track CPU, memory, and database performance
- **Threshold alerts**: Set performance budgets and alerts

---

## How We'll Use It

k6 will load test our API endpoints and identify performance bottlenecks:

**Example 1: Basic API load test**
```javascript
// api-load-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '2m', target: 100 }, // Ramp up to 100 users
    { duration: '5m', target: 100 }, // Stay at 100 users
    { duration: '2m', target: 200 }, // Ramp up to 200 users
    { duration: '5m', target: 200 }, // Stay at 200 users
    { duration: '2m', target: 0 },   // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(99)<1500'], // 99% of requests < 1.5s
    http_req_failed: ['rate<0.1'],     // Error rate < 10%
  },
};

export default function () {
  const response = http.get('https://api.financial-dashboard.com/api/dashboard');
  
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 1000ms': (r) => r.timings.duration < 1000,
    'has revenue data': (r) => r.json().hasOwnProperty('revenue'),
  });
  
  sleep(Math.random() * 3 + 1); // Random sleep 1-4 seconds
}
```

**Example 2: AI query performance test**
```javascript
// ai-query-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

const questions = [
  'What is total revenue?',
  'Show expenses by category',
  'What were profits last quarter?',
  'Top 5 customers by revenue',
  'Monthly revenue trend'
];

export const options = {
  vus: 10, // 10 virtual users
  duration: '5m',
  thresholds: {
    http_req_duration: ['p(95)<10000'], // AI queries can take longer
  },
};

export default function () {
  const question = questions[Math.floor(Math.random() * questions.length)];
  
  const payload = JSON.stringify({
    question: question
  });
  
  const params = {
    headers: {
      'Content-Type': 'application/json',
    },
  };
  
  const response = http.post(
    'https://api.financial-dashboard.com/api/ask',
    payload,
    params
  );
  
  check(response, {
    'AI query successful': (r) => r.status === 200,
    'has answer': (r) => r.json().hasOwnProperty('answer'),
    'has SQL': (r) => r.json().hasOwnProperty('sql'),
    'response time acceptable': (r) => r.timings.duration < 15000,
  });
  
  sleep(Math.random() * 5 + 2); // Random sleep 2-7 seconds
}
```

**Example 3: Database connection pool test**
```javascript
// connection-pool-test.js
import http from 'k6/http';
import { check } from 'k6';

export const options = {
  stages: [
    { duration: '1m', target: 50 },
    { duration: '2m', target: 200 },
    { duration: '1m', target: 500 }, // Stress test connections
  ],
};

export default function () {
  // Test multiple endpoints that hit database
  const endpoints = [
    '/api/dashboard',
    '/api/transactions?limit=10',
    '/api/accounts'
  ];
  
  endpoints.forEach(endpoint => {
    const response = http.get(`https://api.financial-dashboard.com${endpoint}`);
    check(response, {
      'database query successful': (r) => r.status === 200,
    });
  });
}
```

**Example 4: Spike test for sudden traffic**
```javascript
// spike-test.js
export const options = {
  stages: [
    { duration: '10s', target: 10 },   // Normal load
    { duration: '10s', target: 1000 }, // Sudden spike
    { duration: '10s', target: 10 },   // Back to normal
  ],
};

export default function () {
  http.get('https://api.financial-dashboard.com/api/dashboard');
}
```

**Example 5: Custom metrics and thresholds**
```javascript
// custom-metrics-test.js
import http from 'k6/http';
import { check, Trend } from 'k6';

const dashboardLoadTime = new Trend('dashboard_load_time');

export const options = {
  thresholds: {
    dashboard_load_time: ['p(95)<2000'], // 95% of dashboard loads < 2s
    http_req_duration: ['avg<1000'],     // Average response < 1s
  },
};

export default function () {
  const response = http.get('https://api.financial-dashboard.com/api/dashboard');
  
  dashboardLoadTime.add(response.timings.duration);
  
  check(response, {
    'dashboard loads quickly': (r) => r.timings.duration < 3000,
  });
}
```

---

## Key Concepts

- **Virtual Users (VUs)**: Simulated concurrent users
- **Stages**: Define load patterns over time
- **Thresholds**: Performance requirements and alerts
- **Checks**: Validate response correctness
- **Metrics**: Built-in and custom performance measurements
- **Scenarios**: Different test patterns and configurations

---

## Alternatives We Considered

- **Apache JMeter**: Complex XML configuration
- **Locust**: Python-only, less integrated with JS ecosystem
- **Artillery**: Good but less mature than k6
- **Manual testing**: Cannot simulate realistic load patterns

---

## Getting Started

1. **Install k6**: Download from k6.io or use package manager
2. **Write test script**: Create .js file with test logic
3. **Run locally**: `k6 run script.js`
4. **Run with options**: `k6 run --vus 10 --duration 30s script.js`
5. **View results**: Analyze metrics and thresholds

---

## Common Patterns & Best Practices

1. **Start small**: Test with low load first, then scale up
2. **Realistic scenarios**: Mimic actual user behavior patterns
3. **Monitor resources**: Watch server metrics during tests
4. **Set meaningful thresholds**: Based on user experience requirements
5. **Run regularly**: Include in CI/CD for regression testing

---

## Troubleshooting

**Issue 1:** Tests failing due to resource limits  
**Solution:** Adjust VU count and test duration

**Issue 2:** Inconsistent results  
**Solution:** Use proper randomization and warm-up periods

---

## Learning Resources

**Essential:**
- [k6 Documentation](https://k6.io/docs/)
- [Getting Started](https://k6.io/docs/get-started/)

**Recommended:**
- [k6 Load Testing Guide](https://k6.io/docs/testing-guides/)
- [Performance Testing Best Practices](https://k6.io/docs/testing-guides/running-large-tests/)

**Community:**
- [k6 Community Forum](https://community.k6.io/)
- [k6 GitHub](https://github.com/grafana/k6)

---

**Related Technologies:**
- [FastAPI](fastapi.md) - API being load tested
- [AWS ECS Fargate](aws-ecs-fargate.md) - Infrastructure being tested
- [Grafana](grafana.md) - Visualization of test results
