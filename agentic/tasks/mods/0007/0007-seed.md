# Module 0007 Seed: RDS Auto-Stop/Start Cost Management + Authentication

## Initial Concept

Create an automated system to stop and start the AWS RDS database instance based on usage patterns, reducing 24/7 hosting costs for a POC application that won't be used continuously. Additionally, implement a stateless authentication system that works independently of database availability, enabling users to authenticate even when the RDS instance is stopped.

---

## Problem Statement

### Current State Challenges
- RDS instance runs 24/7 on AWS, incurring ~$50-150/month even when unused
- POC application used intermittently (business hours, demos, testing)
- Database sits idle nights, weekends, holidays
- No mechanism to automatically stop/start based on demand
- Manual stop/start via AWS Console is error-prone and forgotten
- **No authentication system** - application is currently open/unsecured
- Auth typically requires database for user lookups, but DB may be stopped when user arrives

### Cost Impact
- **Current:** db.t3.micro running 730 hours/month = ~$50/month minimum
- **Potential:** 40 hours/week usage = ~160 hours/month = ~$11/month (78% savings)
- **At scale:** db.t3.small or larger could save $100-300/month

---

## Solution Vision

### What We're Building
An intelligent RDS lifecycle management system with stateless authentication that:
- **Authenticates users without database** using JWT tokens (Auth0, Clerk, or similar)
- **Automatically stops** RDS after period of inactivity
- **Automatically starts** RDS when application receives traffic
- **Handles cold starts** gracefully with user feedback
- **Separates authentication from authorization** - identity verification works offline, permissions load when DB available
- **Provides controls** to keep running during demos or extended work sessions
- **Logs activity** for cost tracking and optimization

### How It Works (High-Level)

**Authentication Flow (DB-Independent):**
1. User visits app and sees login screen
2. User authenticates via Auth0/Clerk (email/password, Google SSO, etc.)
3. JWT token issued and stored in browser (no DB query needed)
4. User is authenticated and can access basic UI
5. App attempts to load user permissions/data â†’ DB query needed

**RDS Auto-Stop/Start Flow:**
1. Backend monitor tracks last query timestamp
2. After 1 hour of inactivity, automatically stops RDS
3. When authenticated user tries to access data, backend detects DB connection failure
4. Shows modal: "Database is paused to save costs. Would you like to restart it?"
5. User clicks "Yes, restart database"
6. Triggers RDS start via Lambda, shows progress (~60 seconds)
7. Once ready, permissions/data load and user proceeds with normal operations

---

## Known Requirements

### Core Functionality (Must-Have)

1. **Stateless Authentication (DB-Independent)**
   - Integrate Auth0, Clerk, or AWS Cognito for user authentication
   - Issue JWT tokens upon successful login (no DB required)
   - Frontend stores token in localStorage/sessionStorage
   - Backend validates JWT signature (stateless, no DB lookup)
   - Basic user info (name, email, user_id) embedded in JWT claims
   - Login/logout flows work regardless of RDS state
   - Protected routes enforce valid JWT before rendering

2. **DB-Dependent Authorization (Permissions)**
   - Once authenticated, load user permissions from database
   - Store roles (admin, user, viewer) in PostgreSQL `users` table
   - If DB is down when permissions needed, show restart prompt
   - Cache basic permissions in JWT claims to allow graceful degradation
   - Admin features (RDS controls, cost tracking) require `admin` role from DB

3. **Auto-Stop Mechanism**
   - EventBridge scheduled rule checks last activity
   - Stops RDS if no queries in last 60 minutes (configurable)
   - Logs stop events with timestamp and reason
   - Sends notification (email/Slack) when stopped
   - **Weekly Auto-Start:** Starts RDS every Tuesday at 4am regardless of state (AWS requires RDS restart within 7 days)

4. **User-Initiated Restart**
   - Authenticated user tries to access data (KPIs, AI questions, etc.)
   - Backend detects database connection failure
   - Returns specific error code (e.g., `DB_UNAVAILABLE`)
   - Frontend shows modal prompting user to restart database
   - User confirms restart request
   - API Gateway + Lambda endpoint starts RDS (requires auth token)
   - Frontend polls RDS status until available (~60 seconds)
   - Once available, automatically retries the original request
   - Permissions/data load normally

5. **Manual Controls (Admin UI)**
   - **Auth Required:** Only authenticated users with `admin` role can access
   - "Keep Alive" button to prevent auto-stop for N hours
   - "Stop Now" button to immediately stop RDS
   - Status indicator showing: Running, Stopping, Stopped, Starting
   - Display last activity timestamp and estimated stop time
   - Show currently logged-in admin's name/email

6. **Cost Tracking**
   - Log all start/stop events with timestamps
   - Calculate running hours per day/week/month
   - Display estimated monthly cost savings
   - Export usage reports

7. **Graceful Degradation**
   - **Authentication always works** (independent of DB state)
   - If RDS is down, show limited UI with "data unavailable" message
   - If RDS start fails, show clear error with support contact
   - Timeout handling (don't wait forever for DB startup)
   - Retry logic with exponential backoff
   - Fallback to "maintenance mode" message if repeated failures
   - Authenticated users can still access help/docs/contact pages

### Users
- **Primary:** All application users (transparent cold starts)
- **Secondary:** Admin users (manual controls, cost monitoring)
- **Tertiary:** Developers (debugging start/stop issues)

### Out of Scope (v1)
- Multi-factor authentication (MFA)
- Password reset flows (handled by Auth0/Clerk)
- User registration/invite system (manual user creation initially)
- Role management UI (hardcode roles in database for now)
- Predictive scheduling (ML-based usage patterns)
- Multi-region RDS orchestration
- Automatic scaling based on query load
- Integration with other AWS cost optimization tools

---

## Technical Context

### AWS Resources Needed
- **Auth Provider:** Auth0, Clerk, or AWS Cognito for user authentication
- **Lambda Function:** Start/stop RDS, check status, validate JWT tokens
- **EventBridge Rules:** 
  - Scheduled checks for inactivity (every 10-15 minutes)
  - Weekly auto-start (Tuesday 4am) to comply with AWS 7-day limit
- **IAM Role:** Lambda permissions to manage RDS
- **CloudWatch Logs:** Activity tracking
- **DynamoDB Table (optional):** Store activity logs for fast querying
- **Secrets Manager:** Store Auth0/Clerk API keys, JWT signing secrets

### Existing Infrastructure
- RDS PostgreSQL instance: `superscapes-poc` (or similar)
- Vercel backend serverless functions
- Frontend React app with API client
- Admin panel structure (Module 0001)

### Integration Points
- **Auth Provider Integration:** Frontend/backend configured with Auth0/Clerk SDK
- **JWT Validation Middleware:** Backend validates all API requests (except public endpoints)
- Frontend API client: Add Authorization header with JWT token
- Frontend API client: Add retry logic with RDS start trigger on `DB_UNAVAILABLE` error
- Backend health check: Report database connectivity status
- Backend auth check: Separate JWT validation (always works) from DB permission lookup (requires DB)
- Admin UI: Add login/logout UI components
- Admin UI: Add RDS control panel section (admin-only)
- Protected routes: Frontend enforces auth before rendering sensitive pages
- Monitoring: CloudWatch dashboard for start/stop metrics + auth success/failure rates

---

## Data Structure (Initial Idea)

### PostgreSQL Table: `users` (new table for auth)
```sql
CREATE TABLE core.users (
  user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  auth_provider_id VARCHAR(255) UNIQUE NOT NULL,  -- Auth0/Clerk user ID
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255),
  role VARCHAR(50) DEFAULT 'user',  -- 'admin', 'user', 'viewer'
  created_at TIMESTAMP DEFAULT NOW(),
  last_login TIMESTAMP,
  is_active BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_users_auth_provider ON core.users(auth_provider_id);
CREATE INDEX idx_users_email ON core.users(email);
```

### DynamoDB Table: `rds_activity_log`
```
{
  "event_id": "uuid",
  "timestamp": "2025-11-01T14:30:00Z",
  "event_type": "start|stop|query|keepalive",
  "triggered_by": "auto|user|admin",
  "user_id": "uuid",  -- references core.users.user_id
  "user_email": "admin@example.com",  -- for easy lookup
  "duration_seconds": 3600,  // if stop event
  "cost_estimate": 0.15,     // hours * rate
  "metadata": {
    "reason": "inactivity timeout",
    "db_instance": "superscapes-poc"
  }
}
```

### PostgreSQL Table: `system_variables` (add columns)
```sql
ALTER TABLE core.system_variables
ADD COLUMN rds_auto_stop_enabled BOOLEAN DEFAULT TRUE,
ADD COLUMN rds_inactivity_minutes INTEGER DEFAULT 60,
ADD COLUMN rds_last_query_time TIMESTAMP,
ADD COLUMN rds_keepalive_until TIMESTAMP;
```

---

## Key Features Detail

### 1. Authentication Flow (DB-Independent)

**Login Process:**
```
User visits app (unauthenticated)
  â†“
Redirected to Clerk/Auth0 login page
  â†“
User enters credentials or uses Google SSO
  â†“
Auth provider validates credentials
  â†“
JWT token issued with claims:
  - sub: auth_provider_id (e.g., "auth0|123abc")
  - email: "user@example.com"
  - name: "John Doe"
  - exp: expiration timestamp
  â†“
Token stored in browser localStorage
  â†“
Frontend redirects to app dashboard
  â†“
App attempts to load user permissions from DB
  â†“
If DB is down â†’ show restart prompt
If DB is up â†’ load role from core.users table
  â†“
User sees appropriate UI based on role (admin vs user)
```

**Authorization Check (Requires DB):**
- Backend middleware validates JWT signature (stateless, fast)
- For admin-only routes, query `core.users` table for role
- If DB down when role needed, return `DB_UNAVAILABLE` error
- Frontend prompts user to restart DB
- Cache role in JWT claims on next login to reduce DB lookups

### 2. Inactivity Detection

**Backend Monitor Approach:**
- Backend middleware updates `rds_last_query_time` on every database query
- Separate Lambda function runs every 10-15 minutes via EventBridge
- Checks if `now() - rds_last_query_time > 60 minutes`
- If true, stops RDS instance and logs event
- Simple, reliable, activity-based (not just connection-based)

**Weekly Auto-Start (AWS Compliance):**
- EventBridge rule triggers every Tuesday at 4am CT
- Lambda checks RDS state; if stopped, starts it
- Logs event as "weekly_maintenance_start"
- Prevents AWS from force-starting at unpredictable times (7-day limit)
- RDS can stop again after 60 minutes if no activity

### 3. User-Initiated Restart Experience

**Frontend Flow:**
```
Authenticated user tries to load KPI data
  â†“
API call to /api/kpis fails with DB_UNAVAILABLE error
  â†“
Show modal: "Database is paused to save costs. Restart it?"
  [Cancel] [Yes, Restart Database]
  â†“
User clicks "Yes, Restart Database"
  â†“
Show loading: "Starting database... This takes about 60 seconds â³"
  â†“
Call /api/admin/rds/start (includes JWT token in Authorization header)
  â†“
Backend validates JWT before starting RDS
  â†“
Poll /api/admin/rds/status every 5 seconds
  â†“
When status = "available":
  - Show success: "Database is ready! âœ“"
  - Automatically retry original /api/kpis request
  - User sees their data
```

**Expected restart time:** 60-90 seconds

**Auth Requirements:**
- User must have valid JWT to trigger restart
- No specific role required (any authenticated user can restart)
- Admin users see additional controls in Admin UI

### 4. Admin Control Panel

**UI Elements:**
- **User Info:** Shows logged-in admin's name/email from JWT
- **Status Badge:** ðŸŸ¢ Running | ðŸŸ¡ Starting | ðŸ”´ Stopped
- **Last Activity:** "Last query: 15 minutes ago"
- **Next Auto-Stop:** "Will auto-stop at: 4:30 PM (in 1h 15m)"
- **Keep Alive Button:** "Keep running for: [2h] [4h] [8h]" (admin-only)
- **Stop Now Button:** "Stop database immediately" (admin-only)
- **Cost Meter:** "Running cost today: $0.45 | This month: $12.30"
- **Logout Button:** Clears JWT and redirects to login

**Role-Based Access:**
- Only users with `role='admin'` in database can access this panel
- If DB is down, show message: "Database must be running to verify admin access"
- Basic status view available to all authenticated users (read-only)

### 5. Safety Features

**Prevent Data Loss:**
- Never stop during active connections
- Wait for all transactions to complete
- Check for long-running queries (> 5 min) before stopping

**Prevent Downtime During Demos:**
- "Demo Mode" toggle: disables auto-stop for 24 hours (admin-only feature)
- Email reminder when demo mode expires

**Failure Handling:**
- If start fails 3 times, disable auto-start and notify admin
- Manual intervention required to re-enable

**Auth Security:**
- All API endpoints require valid JWT (except public health check)
- JWT signature validation happens before any RDS operations
- Expired tokens automatically redirect to login
- Admin operations require both valid JWT and `admin` role in database

---

## Success Metrics

1. **Cost Reduction:** 60-80% reduction in RDS costs within first month
2. **User Experience:** Cold start happens < 5% of sessions (most usage clustered)
3. **Reliability:** 99%+ successful auto-starts (no stuck states)
4. **Transparency:** Users understand cold start delay (clear messaging)
5. **Auth Adoption:** 100% of users authenticate before accessing data
6. **Auth Performance:** Login/JWT validation works even when DB is down (0 DB dependency for auth)

---

## Open Questions for Discovery

**RDS Auto-Stop/Start:**
1. Should inactivity threshold be configurable by admin (30 min, 1 hour, 2 hours)?
2. Should we show a warning before auto-stopping ("No activity for 55 min, stopping soon")?
3. Do we need email/Slack notification when RDS auto-stops?
4. Should "Keep Alive" override be available to prevent stops during extended work sessions?
5. Do we want scheduled stops (e.g., always stop at midnight) in addition to inactivity-based?
6. Should restart confirmation modal include estimated cost info ("Restarting will cost ~$0.15/hour")?

**Authentication:**
7. Which auth provider: Clerk (easiest, best DX), Auth0 (enterprise-ready), or AWS Cognito (AWS ecosystem)?
8. Should we support multiple login methods (email/password + Google SSO + GitHub)?
9. How should first user become admin? Manual SQL insert or environment variable?
10. Should role be cached in JWT claims to reduce DB lookups, or always query fresh?
11. What happens if user's role changes while they're logged in? Force re-login or wait for token expiry?
12. Should unauthenticated users see a landing page or immediately redirect to login?
13. Do we need audit logging for all auth events (login, logout, permission denied)?

---

## Example Use Cases

### Use Case 1: First-Time User Login (DB Down)
**Scenario:** User tries to access app on Saturday when DB has been stopped since Friday evening
**Flow:**
1. User visits app URL
2. Redirected to Clerk login screen
3. User signs in with Google
4. JWT token issued, user authenticated
5. Frontend tries to load user permissions from database
6. Backend returns `DB_UNAVAILABLE` error
7. Modal appears: "Database is paused. Restart it?"
8. User clicks "Yes, Restart Database"
9. 60-second wait with progress indicator
10. Database starts, permissions load (`role='user'`)
11. User sees KPI dashboard

**Key Point:** Authentication worked immediately; only data access required DB restart

### Use Case 2: Weekend Cost Savings
**Friday 5 PM:** Last user logs out, makes final query
**Friday 7 PM:** Inactivity timeout reached, RDS auto-stops
**Saturday-Sunday:** RDS remains stopped (saving ~$7)
**Monday 8 AM:** First user logs in, triggers auto-start
**Monday 8:02 AM:** Database ready, user proceeds normally
**Savings:** ~48 hours stopped = 66% weekend cost reduction

### Use Case 3: Demo Preparation (Admin)
**Admin before client demo:**
1. Logs in with admin credentials
2. Opens Admin panel (role verified from database)
3. Clicks "Keep Alive: 4 hours"
4. System disables auto-stop until 2 PM
5. Demo proceeds without cold start risk
6. After demo, auto-stop resumes normal schedule

### Use Case 4: Cost Tracking (Admin)
**End of month:**
1. Admin logs in and opens cost tracking dashboard
2. Sees: "RDS ran 180 hours this month (25% uptime)"
3. Actual cost: $13.50 vs $50 if always-on
4. Savings: $36.50/month (73% reduction)
5. Downloads CSV report of all start/stop events with user attribution

### Use Case 5: Permission Denied (Non-Admin)
**Regular user tries to access admin controls:**
1. User logs in with JWT (authenticated)
2. Tries to navigate to `/admin/rds`
3. Backend queries database for user's role
4. Role = 'user' (not 'admin')
5. Returns 403 Forbidden
6. Frontend shows: "Admin access required. Contact your administrator."

---

## Phase 1 MVP Scope

**Must Have - Authentication:**
- Clerk integration (or Auth0/Cognito)
- JWT token issuance and validation
- Frontend login/logout UI
- Backend middleware to validate JWT on all protected routes
- PostgreSQL `core.users` table with role column
- Backend endpoint to sync user from auth provider to database
- Protected routes in frontend (redirect to login if no token)
- Role-based authorization (admin vs user)

**Must Have - RDS Auto-Stop/Start:**
- Lambda to start/stop RDS via API (JWT-protected)
- EventBridge scheduled check for inactivity (every 10-15 min)
- EventBridge weekly auto-start (Tuesday 4am)
- Frontend restart prompt modal (authenticated users only)
- Admin status indicator (running/stopped)
- Basic activity logging to DynamoDB with user attribution

**Nice to Have (v2):**
- "Keep Alive" manual override (admin-only)
- Cost tracking dashboard with user breakdown
- Scheduled stops (always stop at midnight)
- Slack/email notifications
- Predictive scheduling based on usage patterns
- Multi-factor authentication (MFA)
- Audit log for all auth and admin actions

---

## Related Files

**Authentication:**
- Frontend API client: `poc/frontend/src/api/client.ts` (add Authorization header, JWT storage)
- Backend auth middleware: `poc/backend/api/admin/ai_questions.py` (replace placeholder `require_admin()`)
- Backend config: `poc/backend/config.py` (add AUTH0_DOMAIN, AUTH0_CLIENT_ID, etc.)
- Frontend app: `poc/frontend/src/App.tsx` (add protected routes)
- New: `poc/frontend/src/contexts/AuthContext.tsx` (auth state management)
- New: `poc/frontend/src/components/LoginPage.tsx` (login UI)
- New: `poc/backend/auth.py` (JWT validation utilities)

**RDS Management:**
- Admin panel: `poc/frontend/src/pages/AdminPage.tsx` (add RDS control section)
- Database config: `poc/backend/database.py` (add connection retry logic)
- New: Lambda function for RDS start/stop
- New: EventBridge rules configuration (IaC or manual setup)
- New: `poc/frontend/src/components/RDSRestartModal.tsx`
- New: `poc/backend/api/admin/rds.py` (RDS control endpoints)

---

## Lambda Function Pseudo-Code

### Start RDS (JWT-Protected)
```python
import boto3
import os
import jwt
from jwt import PyJWKClient

def lambda_handler(event, context):
    # Validate JWT token
    token = event['headers'].get('Authorization', '').replace('Bearer ', '')
    try:
        # Validate JWT signature (Auth0/Clerk public key)
        jwks_url = os.environ['AUTH_JWKS_URL']
        jwks_client = PyJWKClient(jwks_url)
        signing_key = jwks_client.get_signing_key_from_jwt(token)
        payload = jwt.decode(token, signing_key.key, algorithms=['RS256'])
        user_email = payload.get('email')
    except Exception as e:
        return {
            'statusCode': 401,
            'body': {'error': 'Invalid or expired token'}
        }
    
    # Start RDS instance
    rds = boto3.client('rds')
    db_instance = os.environ['DB_INSTANCE_ID']
    
    response = rds.start_db_instance(DBInstanceIdentifier=db_instance)
    
    # Log event to DynamoDB
    log_event('start', 'user', user_email)
    
    return {
        'statusCode': 200,
        'body': {
            'status': 'starting',
            'instance': db_instance,
            'message': 'Database is starting. This takes ~60 seconds.',
            'triggered_by': user_email
        }
    }
```

### Check Inactivity (EventBridge trigger - every 10-15 min)
```python
def check_and_stop(event, context):
    # Query system_variables.rds_last_query_time
    # If now() - last_query > threshold, stop instance
    # Log event to DynamoDB
    pass
```

### Weekly Auto-Start (EventBridge trigger - Tuesday 4am)
```python
def weekly_maintenance_start(event, context):
    rds = boto3.client('rds')
    db_instance = os.environ['DB_INSTANCE_ID']
    
    # Check current state
    response = rds.describe_db_instances(DBInstanceIdentifier=db_instance)
    state = response['DBInstances'][0]['DBInstanceStatus']
    
    if state == 'stopped':
        rds.start_db_instance(DBInstanceIdentifier=db_instance)
        log_event('weekly_maintenance_start', 'AWS 7-day compliance')
    
    return {'statusCode': 200, 'message': 'Weekly check complete'}
```

---

**Next Step:** Run "Do Step 1 for module 0007" using this seed as the starting point.
